package com.javapuzzler.test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;

import org.junit.jupiter.api.Test;

public class Ch02_CharSequencePuzzle {

    @Test
    public void plusChar() {
        /**
         * 결론 : char 형의 문자열 합치기는 "" 를 더해준다. StringBuilder를 쓴다. StringBuffer를 쓴다.
         * char + char 는 int형으로 계산됨.
         * char형을 문자로 결합 하려면.
         * 1. StringBuilder나 StringBuffer를 쓰거나
         * 2. 맨 앞에다 빈 문자열을 추가해줘야 함.
         * "" + 'H' + 'a' => "Ha"
         */
        char h = 'H';
        char a = 'a';
        assertNotEquals(h + a , "Ha");
        System.out.println(h + a); // char 간의 사칙연산은 정말 사칙연산으로 취급되어 Ha가 아닌 169가 출력된다.

        // Ha 를 출력하게 하기 위해서는?
        StringBuilder sb = new StringBuilder(h + a); // 이러면 안됨. 공백이 출력됨.
        // char형 h + a 는 169가 되는데, StringBuilder 생성자에 숫자를 넣으면 capacity로 인식함. 169개의 공간이 생성되는 것.
        // 그래서 초기값은 "" 가 되고 아무것도 출력하지 않게 되는 것.
        System.out.println(sb.toString());

        sb.append(h);
        sb.append(a);
        System.out.println(sb.toString());

        // 혹은 맨앞에다가 "" 를 붙여줘서 자동형변환이 일어나게 해주기.
        System.out.println("" + h + a);

        // 다음은 어떤것이 출력될까?
        System.out.println("2 + 2 = " +  2 + 2); // 예상으론 2 + 2 = 22가 출력될 것.
    }

    @Test
    public void abc() {
        /** char 배열은 String.valueOf 를 통해서 문자열 형태로 변경 가능 하다. */
        String letters = "ABC";
        char[] numbers = {'1','2','3'}; // char 문자열.
        System.out.println(letters + " easy as " + numbers); // 'ABC easy as [C@543c6f6d'를 반환.

        System.out.println(letters + " easy as " + String.valueOf(numbers)); // 'ABC easy as 123' 을 정상적으로 출력.

        System.out.print(numbers); // 이것도 123 출력.
    }

    @Test
    public void animalFarm() {
        final String pig = "length: 10";
        final String dog = "length: " + pig.length();
        System.out.println("Animals are equal : " + pig == dog); // false 만 출력됨.
        // + 연산자가 == 연산자보다 우선순위가 높다.
        // 따라서 위의 식은 ("Animals are equal : " + pig) == dog 로 계산된다.

        // 자바는 문자열을 intern 해서 사용한다.
        // intern이란 무엇인가?
        String a = "animal";
        String b = "animal";
        assertEquals(a, b); // pass.
        System.out.println(a == b);
        // 통과가 되기는 하는데 "animal" == "animal" 로 비교해서 통과가 된게 아님.
        // String을 == 로 비교하면 메모리 주소값으로 비교함. 두 메모리 주소가 같아서 true.
        // "animal" 을 하나의 메모리공간에 넣어두고 두 변수가 같이 참조함. 메모리를 절약하기 위해서.
        // 이게 바로 intern 임.

        // 만약 별도의 메모리 공간에 저장하고 싶으면? new String() 으로 생성한다.
        String c = new String("animal");
        String d = new String("animal");

        System.out.println(b == c); // 메모리 주소값 다름. false.
        System.out.println(c == d); // 메모리 주소값 다름. false.

        // 따라서 아래와 같이 고쳐서 봐야함. 그러나...
        System.out.println("Animals are equal : " + (pig == dog)); // false.
        // 문자열이 다르기 때문에 intern이 일어나지 않음. 서로 다른 메모리 주소값을 참조하므로 false.

        System.out.println("Animals are equal : " + pig.equals(dog));
    }

    @Test
    public void strangeWorldHelloWorld() {
        // 주석에서도 이스케이프 시퀀스는 작동한다.
        /**
         * Generated by the IBM IDL-to-Java compiler, version 1.0 from
         * F:\TestRoot\apps\a1\units\include\PolicyHome.idl Wednesday, June 17, 1998 6:44:40 o' clock.
         */
        System.out.print("Hell");
        System.out.println("o world");

        // 위 코드는 실행조차 안됨. 주석에서도 \u 는 유니코드 시작으로 인식됨.
        // \u0052 이런식으로.
    }

}